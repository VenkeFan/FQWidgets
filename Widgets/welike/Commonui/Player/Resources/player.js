/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/loadjs/dist/loadjs.umd.js":
/*!************************************************!*\
  !*** ./node_modules/loadjs/dist/loadjs.umd.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(this, function() {\n/**\n * Global dependencies.\n * @global {Object} document - DOM\n */\n\nvar devnull = function() {},\n    bundleIdCache = {},\n    bundleResultCache = {},\n    bundleCallbackQueue = {};\n\n\n/**\n * Subscribe to bundle load event.\n * @param {string[]} bundleIds - Bundle ids\n * @param {Function} callbackFn - The callback function\n */\nfunction subscribe(bundleIds, callbackFn) {\n  // listify\n  bundleIds = bundleIds.push ? bundleIds : [bundleIds];\n\n  var depsNotFound = [],\n      i = bundleIds.length,\n      numWaiting = i,\n      fn,\n      bundleId,\n      r,\n      q;\n\n  // define callback function\n  fn = function (bundleId, pathsNotFound) {\n    if (pathsNotFound.length) depsNotFound.push(bundleId);\n\n    numWaiting--;\n    if (!numWaiting) callbackFn(depsNotFound);\n  };\n\n  // register callback\n  while (i--) {\n    bundleId = bundleIds[i];\n\n    // execute callback if in result cache\n    r = bundleResultCache[bundleId];\n    if (r) {\n      fn(bundleId, r);\n      continue;\n    }\n\n    // add to callback queue\n    q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];\n    q.push(fn);\n  }\n}\n\n\n/**\n * Publish bundle load event.\n * @param {string} bundleId - Bundle id\n * @param {string[]} pathsNotFound - List of files not found\n */\nfunction publish(bundleId, pathsNotFound) {\n  // exit if id isn't defined\n  if (!bundleId) return;\n\n  var q = bundleCallbackQueue[bundleId];\n\n  // cache result\n  bundleResultCache[bundleId] = pathsNotFound;\n\n  // exit if queue is empty\n  if (!q) return;\n\n  // empty callback queue\n  while (q.length) {\n    q[0](bundleId, pathsNotFound);\n    q.splice(0, 1);\n  }\n}\n\n\n/**\n * Execute callbacks.\n * @param {Object or Function} args - The callback args\n * @param {string[]} depsNotFound - List of dependencies not found\n */\nfunction executeCallbacks(args, depsNotFound) {\n  // accept function as argument\n  if (args.call) args = {success: args};\n\n  // success and error callbacks\n  if (depsNotFound.length) (args.error || devnull)(depsNotFound);\n  else (args.success || devnull)(args);\n}\n\n\n/**\n * Load individual file.\n * @param {string} path - The file path\n * @param {Function} callbackFn - The callback function\n */\nfunction loadFile(path, callbackFn, args, numTries) {\n  var doc = document,\n      async = args.async,\n      maxTries = (args.numRetries || 0) + 1,\n      beforeCallbackFn = args.before || devnull,\n      pathStripped = path.replace(/^(css|img)!/, ''),\n      isCss,\n      e;\n\n  numTries = numTries || 0;\n\n  if (/(^css!|\\.css$)/.test(path)) {\n    isCss = true;\n\n    // css\n    e = doc.createElement('link');\n    e.rel = 'stylesheet';\n    e.href = pathStripped; //.replace(/^css!/, '');  // remove \"css!\" prefix\n  } else if (/(^img!|\\.(png|gif|jpg|svg)$)/.test(path)) {\n    // image\n    e = doc.createElement('img');\n    e.src = pathStripped;    \n  } else {\n    // javascript\n    e = doc.createElement('script');\n    e.src = path;\n    e.async = async === undefined ? true : async;\n  }\n\n  e.onload = e.onerror = e.onbeforeload = function (ev) {\n    var result = ev.type[0];\n\n    // Note: The following code isolates IE using `hideFocus` and treats empty\n    // stylesheets as failures to get around lack of onerror support\n    if (isCss && 'hideFocus' in e) {\n      try {\n        if (!e.sheet.cssText.length) result = 'e';\n      } catch (x) {\n        // sheets objects created from load errors don't allow access to\n        // `cssText`\n        result = 'e';\n      }\n    }\n\n    // handle retries in case of load failure\n    if (result == 'e') {\n      // increment counter\n      numTries += 1;\n\n      // exit function and try again\n      if (numTries < maxTries) {\n        return loadFile(path, callbackFn, args, numTries);\n      }\n    }\n\n    // execute callback\n    callbackFn(path, result, ev.defaultPrevented);\n  };\n\n  // add to document (unless callback returns `false`)\n  if (beforeCallbackFn(path, e) !== false) doc.head.appendChild(e);\n}\n\n\n/**\n * Load multiple files.\n * @param {string[]} paths - The file paths\n * @param {Function} callbackFn - The callback function\n */\nfunction loadFiles(paths, callbackFn, args) {\n  // listify paths\n  paths = paths.push ? paths : [paths];\n\n  var numWaiting = paths.length,\n      x = numWaiting,\n      pathsNotFound = [],\n      fn,\n      i;\n\n  // define callback function\n  fn = function(path, result, defaultPrevented) {\n    // handle error\n    if (result == 'e') pathsNotFound.push(path);\n\n    // handle beforeload event. If defaultPrevented then that means the load\n    // will be blocked (ex. Ghostery/ABP on Safari)\n    if (result == 'b') {\n      if (defaultPrevented) pathsNotFound.push(path);\n      else return;\n    }\n\n    numWaiting--;\n    if (!numWaiting) callbackFn(pathsNotFound);\n  };\n\n  // load scripts\n  for (i=0; i < x; i++) loadFile(paths[i], fn, args);\n}\n\n\n/**\n * Initiate script load and register bundle.\n * @param {(string|string[])} paths - The file paths\n * @param {(string|Function)} [arg1] - The bundleId or success callback\n * @param {Function} [arg2] - The success or error callback\n * @param {Function} [arg3] - The error callback\n */\nfunction loadjs(paths, arg1, arg2) {\n  var bundleId,\n      args;\n\n  // bundleId (if string)\n  if (arg1 && arg1.trim) bundleId = arg1;\n\n  // args (default is {})\n  args = (bundleId ? arg2 : arg1) || {};\n\n  // throw error if bundle is already defined\n  if (bundleId) {\n    if (bundleId in bundleIdCache) {\n      throw \"LoadJS\";\n    } else {\n      bundleIdCache[bundleId] = true;\n    }\n  }\n\n  // load scripts\n  loadFiles(paths, function (pathsNotFound) {\n    // execute callbacks\n    executeCallbacks(args, pathsNotFound);\n\n    // publish bundle load event\n    publish(bundleId, pathsNotFound);\n  }, args);\n}\n\n\n/**\n * Execute callbacks when dependencies have been satisfied.\n * @param {(string|string[])} deps - List of bundle ids\n * @param {Object} args - success/error arguments\n */\nloadjs.ready = function ready(deps, args) {\n  // subscribe to bundle load event\n  subscribe(deps, function (depsNotFound) {\n    // execute callbacks\n    executeCallbacks(args, depsNotFound);\n  });\n\n  return loadjs;\n};\n\n\n/**\n * Manually satisfy bundle dependencies.\n * @param {string} bundleId - The bundle id\n */\nloadjs.done = function done(bundleId) {\n  publish(bundleId, []);\n};\n\n\n/**\n * Reset loadjs dependencies statuses\n */\nloadjs.reset = function reset() {\n  bundleIdCache = {};\n  bundleResultCache = {};\n  bundleCallbackQueue = {};\n};\n\n\n/**\n * Determine if bundle has already been defined\n * @param String} bundleId - The bundle id\n */\nloadjs.isDefined = function isDefined(bundleId) {\n  return bundleId in bundleIdCache;\n};\n\n\n// export\nreturn loadjs;\n\n}));\n\n\n//# sourceURL=webpack:///./node_modules/loadjs/dist/loadjs.umd.js?");

/***/ }),

/***/ "./src/default.js":
/*!************************!*\
  !*** ./src/default.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    depUrl: {\n        youtube: 'https://www.youtube.com/iframe_api'\n    },\n    ue: {\n        disappearInterval: 3000,\n        seeking: 0, // 0 'just move seeking dot', 1 'progress follow seeking and stop playing'\n        seeked: 0, // 0'keep', 'stop', 'play'\n        ended: 0, // 0'seekToStart and stop', 1'keepEnd', 2'loop'\n    },\n    ui: {\n        enableMute: true,\n        enableClose: true,\n        enableToggleScreen: true,\n        more: true, // ['download', 'sourceType'],\n        download: false,\n        sourceType: false, // ['240p', '360p'], only support when video supported change\n    }\n});\n\n//# sourceURL=webpack:///./src/default.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./player */ \"./src/player.js\");\n/* harmony import */ var _style_player_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style/player.css */ \"./src/style/player.css\");\n/* harmony import */ var _style_player_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_player_css__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nif (!window.WelikePlayer) {\n    // whats the fuck！\n    window.WelikePlayer = _player__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_player__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/player.js":
/*!***********************!*\
  !*** ./src/player.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _default__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default */ \"./src/default.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui */ \"./src/ui.js\");\n\n\n\n\n\nclass WelikePlayer {\n    // instance init entry\n    // be careful of list rending when 3rd path library has not been initialized\n    // for this case, there should be a pending list for an 'inited' event\n    // it should be capatible with VDOM frameworks\n\n    static pendingQPush(c, type)  {\n        if (WelikePlayer.supportReady[type]) {\n            console.log('push directly call')\n            c()\n        } else {\n            WelikePlayer.Q.push({type, c})\n        }\n    }\n    static pendingQCall(type) {\n        WelikePlayer.Q.forEach((v) => {\n            if (v.type === type && v.c) {\n                v.c()\n                // call once and remove dep of closure\n                v.c = null\n            }\n        })\n    }\n    destroy() {\n        const targetDom = this.targetDom\n        this.media.player.pause()\n\n        this.media.raw.player.onended = null\n        this.media.raw.player.ontimeupdate = null\n        this.media.raw.player.onpause = null\n        this.media.raw.player.ondurationchange = null\n\n        _ui__WEBPACK_IMPORTED_MODULE_2__[\"default\"].unlinkMedia(this.ui, this.media)\n        Object.keys(this.media.player).forEach((k) => {\n            if (typeof this.media.player[k] === 'function') {\n                this.media.player[k] = null\n            }\n        })\n\n        this.media.raw.player = null\n        this.media.player = null\n\n        if (this.media.timerProgress) {\n            clearTimeout(this.media.timerProgress)\n            this.media.timerProgress = null\n        }\n\n        if (this.media.simulateTimer) {\n            clearInterval(this.media.simulateTimer)\n            this.media.simulateTimer = null\n        }\n        this.media = null\n\n        //clean targetDom: https://coderwall.com/p/nygghw/don-t-use-innerhtml-to-empty-dom-elements and some stackoverflow searching\n        while (targetDom.lastChild) {\n            targetDom.removeChild(targetDom.lastChild)\n        }\n        this.ui = null\n\n        targetDom.wplayer = null\n        targetDom.wpInit = false\n    }\n\n    constructor (targetDom, options) {\n        if (targetDom.wpInit === true && targetDom.wplayer) {\n            return targetDom.wplayer\n        }\n\n        this.config = Object.assign({}, _default__WEBPACK_IMPORTED_MODULE_0__[\"default\"], options)\n        this.ui = _ui__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setup(targetDom, this.config)\n        const supportType = this.config.supportTarget\n        let initCall = null\n\n        const emptyCall = () => {}\n        this.media = {\n            status: {\n                firstframeStart: 0,\n                firstframeEnd: null,\n                currentTime: null,\n                duration: null,\n                startTime: null,\n                readyTime: null,\n                bufferUpdate: null,\n                seekCount: null,\n                mute: null,\n            },\n            timerProgress: null,\n            simulateTimer: null,\n            isPlaying: false,\n            isSeeking: false,\n            isPaused: false,\n            isShowingControl: false,\n            raw: {},\n            player: {},\n            oninited: emptyCall,\n            onpause: emptyCall,\n            onended: emptyCall,\n            ontimeupdate: emptyCall,\n            ondurationchange: emptyCall,\n            onmute: emptyCall,\n            onfirstframe: emptyCall,\n        }\n\n        switch(supportType) {\n            case 'youtube':\n                if (!window.YT) {\n                    if (!window.onYouTubeIframeAPIReady) {\n                        window.onYouTubeIframeAPIReady = function () {\n                            WelikePlayer.supportReady.youtube = true\n                            WelikePlayer.pendingQCall('youtube')\n                        }\n                    }\n                    _util__WEBPACK_IMPORTED_MODULE_1__[\"default\"].loadScript(this.config.depUrl.youtube)\n                } else {\n                    WelikePlayer.supportReady.youtube = true\n                }\n\n                const _onready = (e) => {\n                    const instance = e.target\n                    Object.defineProperties(this.media.player, {\n                        currentTime: {\n                            get() {\n                                return instance.getCurrentTime()\n                            },\n                            set(value) {\n                                instance.seekTo(value)\n                            }\n                        },\n                        duration: {\n                            get() {\n                                return instance.getDuration()\n                            }\n                        },\n                        mute: {\n                            get() {\n                                return instance.isMuted()\n                            },\n                            set(value) {\n                                if (value === true) {\n                                    instance.mute()\n                                } else {\n                                    instance.unMute()\n                                }\n                            }\n                        },\n                        buffer: {\n                            get() {\n                                const end = instance.getVideoLoadedFraction() * instance.getDuration()\n                                return {\n                                    start: 0,\n                                    end\n                                }\n                            }\n                        }\n                    })\n                    this.media.player.play = () => {\n                        instance.playVideo()\n                        this.media.onplay()\n                    }\n                    this.media.player.pause = () => {\n                        instance.pauseVideo()\n                    }\n                    this.media.player.mute = (v) => {\n                        if(v === true) {\n                            player.embed.unMute();\n                        }\n                        this.media.onmute()\n                    }\n                    this.media.player.mute = (v) => {\n                        if (v === true) {\n                            this.media.raw.player.mute()\n                        } else {\n                            this.media.raw.player.unMute()\n                        }\n                        this.media.onmute()\n                    }\n                    _ui__WEBPACK_IMPORTED_MODULE_2__[\"default\"].linkMedia(this.ui, this.media, this.config)\n\n                    this.media.player.pause()\n                    this.media.oninited()\n\n                }\n                const _onstate = (e) => {\n                    switch (e.data) {\n                        // Handle events\n                        // -1   Unstarted\n                        // 0    Ended\n                        // 1    Playing\n                        // 2    Paused\n                        // 3    Buffering\n                        // 5    Video cued\n                        case -1:\n                            // Get loaded % from YouTube\n                            this.media.onfirstframe()\n                            break;\n\n                        case 0:\n                            this.media.onended()\n                            break;\n\n                        case 1:\n                            this.media.ontimeupdate({ target: {}})\n                            this.media.simulateTimer = setInterval(() => {\n                                this.media.ontimeupdate({target: {}})\n                            }, 50)\n                            // Restore paused state (YouTube starts playing on seek if the video hasn't been played yet)\n                            break;\n                        case 2:\n                            // Restore audio (YouTube starts playing on seek if the video hasn't been played yet)\n                            this.media.onpause()\n                            break;\n                        case 3:\n                            this.media.ondurationchange();\n                            break;\n                        default:\n                            break;\n                        }\n                }\n                initCall = () => {\n                    this.media.raw.player = new YT.Player(this.ui.mid, {\n                        height: '100%',\n                        width: '100%',\n                        videoId: options.source,\n                        events: {\n                            'onReady': _onready,\n                            'onStateChange': _onstate\n                        },\n                        playerVars: {\n                            autoplay: 1, // Autoplay\n                            controls: 0, // Only show controls if not fully supported\n                            rel: 0, // No related vids\n                            showinfo: 0, // Hide info,\n                            autohide: 1,\n                            iv_load_policy: 1, // Hide annotations\n                            modestbranding: 1, // Hide logos as much as possible (they still show one in the corner when paused)\n                            disablekb: 1, // Disable keyboard as we handle it\n                            playsinline: 1, // Allow iOS inline playback\n                            wmode: 'opaque',\n                            // Tracking for stats\n                            // origin: window ? `${window.location.protocol}//${window.location.host}` : null,\n                            widget_referrer: window ? window.location.href : null,\n\n                            // Captions are flaky on YouTube\n                            cc_load_policy:  1,\n                            cc_lang_pref: 'auto',\n                        },\n                    });\n                }\n                break;\n            case 'html':\n                initCall = () => {\n                    this.ui.mediaContainer.innerHTML =\n                        `<video width=\"100%\" height=\"100%\"><source src=\"${options.source}\"></video>`\n                    const player = this.ui.mediaContainer.querySelector('video')\n                    this.media.raw.player = player\n                    Object.defineProperties(this.media.player, {\n                        currentTime: {\n                            get() {\n                                return player.currentTime\n                            },\n                            set(value) {\n                                player.currentTime = value\n                            }\n                        },\n                        duration: {\n                            get() {\n                                return player.duration\n                            }\n                        },\n                        mute: {\n                            get() {\n                                return player.muted\n                            },\n                            set(value) {\n                                player.muted = !!value\n                            }\n                        },\n                        buffer: {\n                            //TODO: handle player.buffered.start(0) error\n                            get() {\n                                return {\n                                    start: player.buffered.start(0),\n                                    end: player.buffered.end(0)\n                                }\n                            }\n                        }\n                    })\n                    this.media.player.play = () => {\n                        player.play()\n                        this.media.onplay()\n                    }\n                    this.media.player.pause = () => {\n                        player.pause()\n                    }\n                    this.media.player.mute = (v) => {\n                        player.muted = (v === true)\n                        this.media.onmute()\n                    }\n                    _ui__WEBPACK_IMPORTED_MODULE_2__[\"default\"].linkMedia(this.ui, this.media, this.config)\n\n\n                    player.ondurationchange = (e) => {\n                        return this.media.ondurationchange(e)\n                    }\n\n                    // metadata seems  not surely loaded\n                    player.onloadeddata = (e) => {\n                        return this.media.onfirstframe(e)\n                    }\n\n                    player.onended = (e) => {\n                        return this.media.onended(e)\n                    }\n                    player.ontimeupdate = (e) => {\n                        return this.media.ontimeupdate(e)\n                    }\n                    player.onpause = (e) => {\n                        return this.media.onpause(e)\n                    }\n                    this.media.player.pause()\n                    this.media.oninited()\n                }\n                break;\n\n        }\n\n        targetDom.wpInit = true\n        WelikePlayer.pendingQPush(initCall, supportType)\n        this.targetDom = targetDom\n        return targetDom.wplayer = this\n    }\n}\nWelikePlayer.Q = []\nWelikePlayer.supportReady = {\n    youtube: false,\n    html: true,\n}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (WelikePlayer);\n\n\n//# sourceURL=webpack:///./src/player.js?");

/***/ }),

/***/ "./src/style/player.css":
/*!******************************!*\
  !*** ./src/style/player.css ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/style/player.css?");

/***/ }),

/***/ "./src/ui.js":
/*!*******************!*\
  !*** ./src/ui.js ***!
  \*******************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n\nconst secToTime = (secs) => {\n    const time = parseInt(secs, 10)\n    if (time >= 0) {\n        let min = '0' + parseInt(time / 60, 10)\n        min = min.substr(-2)\n        let sec = '0' + (time % 60)\n        sec = sec.substr(-2)\n        return `${min}:${sec}`\n    }\n    return '--:--'\n}\nconst removeSelfNode = (node) => {\n    console.log(node.parentElement)\n    if (node.parentElement) {\n        node.parentElement.removeChild(node)\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    setup(targetDom, options) {\n        const doc = document\n        const oFragment = doc.createDocumentFragment() // fragment for saving update dom\n        const ui = {}\n        ui.target = targetDom\n        ui.wrapper = doc.createElement('div')\n        ui.wrapper.className = 'wplayer-wrapper'\n        oFragment.appendChild(ui.wrapper)\n\n        ui.mediaLayer = doc.createElement('div')\n        ui.mediaLayer.className = 'media-layer'\n        ui.mid = (Math.random() + 1).toString(36).substring(7) + '_' + new Date().getTime();\n        ui.mediaContainer = doc.createElement('div')\n        ui.mediaContainer.setAttribute('id', ui.mid)\n        ui.mediaLayer.appendChild(ui.mediaContainer)\n        ui.wrapper.appendChild(ui.mediaLayer)\n\n        ui.mediaCover = doc.createElement('div')\n        ui.mediaCover.className = 'media-cover'\n        ui.setVideoPoster = (data) => {\n            if (data) {\n                ui.mediaCover.style.backgroundImage = `url(${data})`\n            } else {\n                ui.mediaCover.style.background = 'transparent'\n            }\n        }\n        if (options.poster) {\n            ui.setVideoPoster(options.poster)\n        }\n        ui.wrapper.appendChild(ui.mediaCover)\n\n        ui.videoCover = doc.createElement('div')\n        ui.videoCover.className = 'video-cover'\n        ui.videoCover.innerHTML = '<div class=\"video-btn play\"></div><div class=\"video-btn stop\"></div>'\n        ui.videoPlayBtn = ui.videoCover.querySelector('.video-btn.play')\n        ui.videoStopBtn = ui.videoCover.querySelector('.video-btn.stop')\n        ui.videoStopBtn.style.display = 'none'\n        ui.wrapper.appendChild(ui.videoCover)\n\n        ui.videoMenu = doc.createElement('div')\n        ui.videoMenu.className = 'video-menu'\n        ui.videoMenu.innerHTML = ' <div class=\"menu-left\"><div class=\"video-close\"></div></div>' +\n            '                <div class=\"menu-right\">' +\n            '                    <div class=\"video-mute\">' +\n            '                        <div class=\"video-mute-icon\"></div>' +\n            '                    </div>' +\n            '                    <div class=\"video-more\">' +\n            '                        <div class=\"video-more-icon\"></div>' +\n            '                        <div class=\"video-more-list\">' +\n            '                            <div class=\"video-download\">download</div>' +\n            '                            <div class=\"video-sourcetype\">' +\n            '                                <div class=\"video-sourcetype-icon\"></div>' +\n            '                                <div class=\"video-source-list\"></div>' +\n            '                            </div>' +\n            '                        </div>' +\n            '                    </div>' +\n            '                </div>'\n        ui.videoClose = ui.videoMenu.querySelector('.video-close')\n        ui.videoMute = ui.videoMenu.querySelector('.video-mute')\n        ui.videoMore = ui.videoMenu.querySelector('.video-more-icon')\n        ui.videoMoreWrap = ui.videoMenu.querySelector('.video-more')\n        ui.videoDownload = ui.videoMenu.querySelector('.video-download')\n        ui.videoSourceType = ui.videoMenu.querySelector('.video-sourcetype-icon')\n        ui.videoSourceList = ui.videoMenu.querySelector('.video-source-list')\n\n\n\n        //TODO: add close\n        if (!options.ui.enableClose) {\n            removeSelfNode(ui.videoClose)\n        }\n        //TODO: add mute\n        if (!options.ui.enableMute) {\n            removeSelfNode(ui.videoMute)\n        }\n\n        //TODO: add more\n        if (!options.ui.more) {\n            removeSelfNode( ui.videoMoreWrap )\n        } else {\n            //TODO: add download\n            if (!options.ui.download) {\n                removeSelfNode(ui.videoDownload)\n            }\n\n            //TODO: add sourcetype\n            if (!options.ui.sourceType) {\n                removeSelfNode(ui.videoSourceType)\n            } else {\n                // init source list\n            }\n        }\n\n\n        ui.wrapper.appendChild(ui.videoMenu)\n\n        ui.videoProg = doc.createElement('div')\n        ui.videoProg.className = 'video-progress'\n        ui.videoProg.innerHTML =  '<div class=\"time\"><span class=\"current\">--:--</span>&nbsp;/&nbsp;<span class=\"duration\">--:--</span></div>'\n            +  '<div class=\"progress-percent\"><div class=\"progress-bar\"></div><div class=\"control-dot-wrap\"><div class=\"control-dot\"></div></div></div>'\n            + '<div class=\"toggle-phone\"><div class=\"toggle-icon\"></div></div>'\n        ui.curTime = ui.videoProg.querySelector('.current')\n        ui.duration = ui.videoProg.querySelector('.duration')\n        ui.videoTogglePhone = ui.videoProg.querySelector('.toggle-phone')\n        if (!options.ui.enableToggleScreen) {\n            ui.videoTogglePhone.style.display = 'none'\n        }\n        ui.videoProgPercent = ui.videoProg.querySelector('.progress-percent')\n        ui.videoProgBar = ui.videoProgPercent.querySelector('.progress-bar')\n        ui.videoProgControl = ui.videoProgPercent.querySelector('.control-dot-wrap')\n\n        ui.wrapper.appendChild(ui.videoProg)\n\n        ui.videoBottomProg = doc.createElement('div')\n        ui.videoBottomProg.className = 'video-bottom-progress'\n        ui.videoBottomProg.innerHTML =  '<div class=\"progress-bar\"></div>'\n        ui.videoBottomProgBar = ui.videoBottomProg.querySelector('.progress-bar')\n        ui.wrapper.appendChild(ui.videoBottomProg)\n\n        targetDom.appendChild(oFragment)\n\n        return ui\n    },\n    unlinkMedia(ui, media) {\n\n        // ui control touch event\n        ui.mediaCover.ontouchstart = null\n        ui.mediaCover.onclick = null\n        ui.videoPlayBtn.onclick = null\n        ui.videoStopBtn.onclick = null\n        const controlDot = ui.videoProgControl\n        controlDot.ontouchstart = null\n        controlDot.ontouchend = null\n        // effitiency？\n        ui.videoProgPercent.ontouchmove = null\n\n        Object.keys(ui).forEach((v) => {\n            if (typeof ui[v] === 'function') {\n                // release closure\n                ui[v] = null\n            }\n        })\n        Object.keys(media).forEach((v) => {\n            if (typeof media[v] === 'function') {\n                // release closure\n                media[v] = null\n            }\n        })\n    },\n    linkMedia(ui, media, options) {\n        const ueSetting = options.ue\n        ui.setProgressBar = (cur, dur) => {\n            const curTime = secToTime(cur)\n            const durationTime = secToTime(dur)\n            let percentage = Number(100 * cur / dur)\n            if (percentage < 0) {\n                percentage = 0\n            }\n            if (percentage > 100) {\n                percentage = 100\n            }\n\n            ui.curTime.innerHTML =  curTime\n            ui.duration.innerHTML = durationTime\n            ui.videoProgBar.style.width = '' + percentage + '%'\n            ui.videoBottomProgBar.style.width = '' + percentage + '%'\n\n            if (!media.isSeeking) {\n                ui.setProgressDot(percentage)\n            }\n        }\n        ui.setProgressDot = (percentage) => {\n            ui.videoProgControl.style.marginLeft = '' + percentage + '%'\n            ui.videoProgControl.dataProgress = percentage\n        }\n        ui.showVideoProgress = () => {\n            ui.videoCover.style.display = 'flex'\n            ui.videoProg.className = 'video-progress active'\n            ui.videoMenu.className = 'video-menu active'\n            ui.videoBottomProg.className = 'video-bottom-progress'\n            media.isShowingControl = true\n            if (media.timerProgress) {\n                clearTimeout(media.timerProgress)\n                media.timerProgress = null\n            }\n        }\n        ui.showVideoProgressTmr = () => {\n            ui.showVideoProgress()\n\n            media.timerProgress = setTimeout(ui.showBottomVideoProgress, ueSetting.disappearInterval > 2000 ? ueSetting.disappearInterval: 2000)\n        }\n        ui.showBottomVideoProgress = () => {\n            ui.videoCover.style.display = 'none'\n            ui.videoProg.className = 'video-progress deactive'\n            ui.videoMenu.className = 'video-menu deactive'\n            ui.videoBottomProg.className = 'video-bottom-progress active'\n            media.isShowingControl = false\n        }\n\n        ui.videoMute.onclick = (e) => {\n            if (media.player.mute) {\n                media.player.mute = false\n                ui.videoMute.className = 'video-mute'\n            } else {\n                media.player.mute = true\n                ui.videoMute.className = 'video-mute muted'\n            }\n        }\n        // disappearInterval: 3000,\n        //         seeking: 0, // 0 'just move seeking dot', 1 'progress follow seeking and stop playing'\n        //         seeked: 0, // 0'keep', 'stop', 'play'\n        //         ended: 0, // 0'seekToStart and stop', 1'keepEnd', 2'loop'\n        // ui control touch event\n        ui.mediaCover.ontouchstart = (e) => {\n            console.log('ontoucheStart')\n            if (!media.isShowingControl) {\n                ui.showVideoProgressTmr()\n            }\n            return false;\n        }\n        ui.mediaCover.onclick = (e) => {\n            return ui.mediaCover.ontouchstart(e)\n        }\n\n        ui.videoPlayBtn.onclick = (e) => {\n            media.isPlaying = true\n            media.isPaused = false\n            ui.videoStopBtn.style.display = 'block';\n            ui.videoPlayBtn.style.display = 'none';\n            media.player.play()\n            return false\n        }\n\n        ui.videoStopBtn.onclick = (e) => {\n            console.log('videoStopBtn click')\n            media.isPlaying = false\n            media.isPaused = true\n            ui.videoStopBtn.style.display = 'none';\n            ui.videoPlayBtn.style.display = 'block';\n            media.player.pause()\n            return false;\n        }\n\n        const controlDot = ui.videoProgControl\n        controlDot.ontouchstart = (e) => {\n            media.isSeeking = true\n            ui.showVideoProgress()\n        }\n        controlDot.ontouchend = (e) => {\n            media.isSeeking = false\n            const per = ui.videoProgControl.dataProgress\n            const duration = media.player.duration\n            const cur = Number(duration * per / 100)\n            // TODO: can be configured\n            media.player.currentTime = cur\n            ui.setProgressBar(cur, duration)\n            ui.showVideoProgressTmr()\n\n            media.status.currentTime = cur\n            media.status.duration = duration\n            _util__WEBPACK_IMPORTED_MODULE_0__[\"default\"].triggerEvent(ui, _util__WEBPACK_IMPORTED_MODULE_0__[\"EVENT\"].seek, { status: media.status })\n\n            switch(ueSetting.seeked) {\n                case 0: // keep\n                    break;\n                case 1: // stop\n                    media.player.pause()\n                    break;\n                case 2: // play\n                    media.player.play()\n                    break;\n            }\n\n        }\n\n        // effitiency？\n        ui.videoProgPercent.ontouchmove = (e) => {\n            console.log(e)\n            const touch = e.changedTouches[0]\n\n            if (!media.isSeeking) return\n            if (!touch) return\n\n            const len = touch.clientX - ui.videoProgPercent.offsetLeft\n            const percent = Number(len * 100 / ui.videoProgPercent.clientWidth)\n            ui.setProgressDot(percent)\n\n            switch (ueSetting.seeking) {\n                case 0: //'just move seeking dot'\n                    break;\n                case 1: //'progress follow seeking and stop playing'\n                    break;\n            }\n        }\n\n        media.oninited = () => {\n            // TODO: can be defined by config\n            media.isPlaying = false\n            media.isPaused = true\n            ui.showVideoProgress()\n\n            media.status.startTime = new Date().getTime()\n            media.status.seekCount = 0\n            _util__WEBPACK_IMPORTED_MODULE_0__[\"default\"].triggerEvent(ui, _util__WEBPACK_IMPORTED_MODULE_0__[\"EVENT\"].inited, {status: media.status})\n        }\n\n        media.onfirstframe = () => {\n            const buffer = media.player.buffer\n            media.status.firstframeStart = buffer.start\n            media.status.firstframeEnd = buffer.end\n            _util__WEBPACK_IMPORTED_MODULE_0__[\"default\"].triggerEvent(ui, _util__WEBPACK_IMPORTED_MODULE_0__[\"EVENT\"].firstframe, {status: media.status})\n        }\n\n        // media event\n        media.onplay = (e) => {\n            media.isPlaying = true\n            media.isPaused = false\n            const currentTime = media.player.currentTime\n            const duration = media.player.duration\n            // set post null\n            ui.setVideoPoster(null)\n            ui.setProgressBar(currentTime, duration)\n            ui.showVideoProgressTmr()\n\n            media.status.currentTime = currentTime\n            media.status.duration = duration\n            _util__WEBPACK_IMPORTED_MODULE_0__[\"default\"].triggerEvent(ui, _util__WEBPACK_IMPORTED_MODULE_0__[\"EVENT\"].play, { status: media.status })\n        }\n\n        media.ontimeupdate = (e) => {\n            media.isPlaying = true\n            media.isPaused = false\n            const currentTime = media.player.currentTime\n            const duration = media.player.duration\n\n            ui.setProgressBar(currentTime, duration)\n\n            media.status.currentTime = currentTime\n            media.status.duration = duration\n            _util__WEBPACK_IMPORTED_MODULE_0__[\"default\"].triggerEvent(ui, _util__WEBPACK_IMPORTED_MODULE_0__[\"EVENT\"].timeupdate, { status: media.status, timeStamp: new Date().getTime(),\n                framesDecoded: e.target.webkitDecodedFrameCount, bytesDecoded: e.target.webkitVideoDecodedByteCount})\n        }\n\n        media.onpause = (e) => {\n            media.isPlaying = false\n            media.isPaused = true\n            ui.showVideoProgress()\n            //TODO: send pause event\n            media.status.currentTime = media.player.currentTime\n            _util__WEBPACK_IMPORTED_MODULE_0__[\"default\"].triggerEvent(ui, _util__WEBPACK_IMPORTED_MODULE_0__[\"EVENT\"].pause, { status: media.status })\n        }\n\n        media.onended = (e) => {\n            media.isPlaying = false\n            media.isPaused = true\n\n            //TODO: send end event\n            switch (ueSetting.ended) {\n                case 0: //'seekToStart and stop'\n                    media.player.currentTime = 0\n                    media.player.pause()\n                    ui.showVideoProgress()\n                    break;\n                case 1: //keepEnd\n                    ui.showVideoProgress()\n                    break;\n                case 2: //loop\n                    media.player.currentTime = 0\n                    media.player.play()\n                    break;\n            }\n            media.status.currentTime = media.player.currentTime\n            _util__WEBPACK_IMPORTED_MODULE_0__[\"default\"].triggerEvent(ui, _util__WEBPACK_IMPORTED_MODULE_0__[\"EVENT\"].ended, { status: media.status })\n        }\n\n        media.ondurationchange = (e) => {\n            const currentTime = media.player.currentTime\n            const duration = media.player.duration\n            ui.setProgressBar(currentTime, duration)\n\n            media.status.currentTime = currentTime\n            media.status.duration = duration\n            _util__WEBPACK_IMPORTED_MODULE_0__[\"default\"].triggerEvent(ui, _util__WEBPACK_IMPORTED_MODULE_0__[\"EVENT\"].durationchange, { status: media.status })\n        }\n\n        media.onmute = (status) => {\n            media.status.mute = status\n            _util__WEBPACK_IMPORTED_MODULE_0__[\"default\"].triggerEvent(ui, _util__WEBPACK_IMPORTED_MODULE_0__[\"EVENT\"].mute, { status: media.status })\n        }\n    }\n});\n\n//# sourceURL=webpack:///./src/ui.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! exports provided: default, EVENT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EVENT\", function() { return EVENT; });\n/* harmony import */ var loadjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loadjs */ \"./node_modules/loadjs/dist/loadjs.umd.js\");\n/* harmony import */ var loadjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loadjs__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    loadScript(url) {\n        return new Promise((resolve, reject) => {\n            loadjs__WEBPACK_IMPORTED_MODULE_0___default()(url, {\n                success: resolve,\n                error: reject,\n            });\n        });\n    },\n    triggerEvent(ui, name, data) {\n        const event = new CustomEvent(name, data)\n        ui.target.dispatchEvent(event)\n    },\n});\n\nconst EVENT = {\n    inited: 'inited',\n    firstframe: 'firstframe',\n    play: 'play',\n    timeupdate: 'timeupdate',\n    pause: 'pause',\n    ended: 'ended',\n    durationchange: 'durationchange',\n    mute: 'mute',\n    seek: 'seek'\n}\n\n//# sourceURL=webpack:///./src/util.js?");

/***/ })

/******/ });