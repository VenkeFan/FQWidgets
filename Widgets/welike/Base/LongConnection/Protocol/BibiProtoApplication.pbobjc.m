// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bibi_proto_application.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "BibiProtoApplication.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - BibiProtoApplicationRoot

@implementation BibiProtoApplicationRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - BibiProtoApplicationRoot_FileDescriptor

static GPBFileDescriptor *BibiProtoApplicationRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protoc"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum MessageClassified

GPBEnumDescriptor *MessageClassified_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "P2P\000Group\000News\000All\000UnknownMessageClassif"
        "ied\000";
    static const int32_t values[] = {
        MessageClassified_P2P,
        MessageClassified_Group,
        MessageClassified_News,
        MessageClassified_All,
        MessageClassified_UnknownMessageClassified,
    };
    static const char *extraTextFormatInfo = "\004\000\003\000\001\005\000\003\003\000\004\007\221\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageClassified)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageClassified_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageClassified_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageClassified_P2P:
    case MessageClassified_Group:
    case MessageClassified_News:
    case MessageClassified_All:
    case MessageClassified_UnknownMessageClassified:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MaterialSource

GPBEnumDescriptor *MaterialSource_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Albums\000Capture\000UnknownMaterialSource\000";
    static const int32_t values[] = {
        MaterialSource_Albums,
        MaterialSource_Capture,
        MaterialSource_UnknownMaterialSource,
    };
    static const char *extraTextFormatInfo = "\003\000\006\000\001\007\000\002\007\216\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MaterialSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MaterialSource_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MaterialSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case MaterialSource_Albums:
    case MaterialSource_Capture:
    case MaterialSource_UnknownMaterialSource:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SerializableType

GPBEnumDescriptor *SerializableType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ProtocolBuffer\000Json\000";
    static const int32_t values[] = {
        SerializableType_ProtocolBuffer,
        SerializableType_Json,
    };
    static const char *extraTextFormatInfo = "\002\000\016\000\001\004\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SerializableType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SerializableType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SerializableType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SerializableType_ProtocolBuffer:
    case SerializableType_Json:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessageHeader

@implementation MessageHeader

@dynamic hasMessageId, messageId;
@dynamic hasClassified, classified;
@dynamic hasFromUid, fromUid;
@dynamic hasRemoteUid, remoteUid;
@dynamic hasCreatetime, createtime;
@dynamic hasType, type;
@dynamic hasPersistent, persistent;
@dynamic hasSourceHostPort, sourceHostPort;
@dynamic hasReadTimes, readTimes;
@dynamic hasExpiredTime, expiredTime;
@dynamic hasReply, reply;
@dynamic propertiesArray, propertiesArray_Count;
@dynamic hasSenderName, senderName;
@dynamic hasSenderURL, senderURL;
@dynamic hasGroupName, groupName;
@dynamic hasGroupURL, groupURL;
@dynamic hasEnableChat, enableChat;
@dynamic hasVisableChat, visableChat;
@dynamic hasIsGreet, isGreet;

typedef struct MessageHeader__storage_ {
  uint32_t _has_storage_[1];
  MessageClassified classified;
  MessageHeader_MessageType type;
  int32_t readTimes;
  NSString *messageId;
  NSString *fromUid;
  NSString *remoteUid;
  NSString *sourceHostPort;
  NSMutableArray *propertiesArray;
  NSString *senderName;
  NSString *senderURL;
  NSString *groupName;
  NSString *groupURL;
  int64_t createtime;
  int64_t expiredTime;
} MessageHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "messageId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_MessageId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, messageId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = MessageClassified_UnknownMessageClassified,
        .core.name = "classified",
        .core.dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .core.number = MessageHeader_FieldNumber_Classified,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, classified),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "fromUid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_FromUid,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, fromUid),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "remoteUid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_RemoteUid,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, remoteUid),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt64 = 0LL,
        .core.name = "createtime",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_Createtime,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, createtime),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt64,
      },
      {
        .defaultValue.valueEnum = MessageHeader_MessageType_UnknownMessageType,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = MessageHeader_MessageType_EnumDescriptor,
        .core.number = MessageHeader_FieldNumber_Type,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "persistent",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_Persistent,
        .core.hasIndex = 6,
        .core.offset = 7,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "sourceHostPort",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_SourceHostPort,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, sourceHostPort),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 3,
        .core.name = "readTimes",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_ReadTimes,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, readTimes),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt64 = -1LL,
        .core.name = "expiredTime",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_ExpiredTime,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, expiredTime),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt64,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "reply",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_Reply,
        .core.hasIndex = 11,
        .core.offset = 12,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "propertiesArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(MessageHeader_Property),
        .core.number = MessageHeader_FieldNumber_PropertiesArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, propertiesArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "senderName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_SenderName,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, senderName),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "senderURL",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_SenderURL,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, senderURL),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "groupName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_GroupName,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, groupName),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "groupURL",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_GroupURL,
        .core.hasIndex = 16,
        .core.offset = (uint32_t)offsetof(MessageHeader__storage_, groupURL),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "enableChat",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_EnableChat,
        .core.hasIndex = 17,
        .core.offset = 18,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "visableChat",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_VisableChat,
        .core.hasIndex = 19,
        .core.offset = 20,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isGreet",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageHeader_FieldNumber_IsGreet,
        .core.hasIndex = 21,
        .core.offset = 22,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageHeader class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(MessageHeader__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\r\001\t\000\003\007\000\004\t\000\010\016\000\t\t\000\n\013\000\r\n\000\016\007!!\000\017\t\000\020\006!!\000\021\n\000\022\013"
        "\000\023\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum MessageHeader_MessageType

GPBEnumDescriptor *MessageHeader_MessageType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Text\000Audio\000Video\000Pic\000Emotion\000Notice\000Unkn"
        "ownMessageType\000";
    static const int32_t values[] = {
        MessageHeader_MessageType_Text,
        MessageHeader_MessageType_Audio,
        MessageHeader_MessageType_Video,
        MessageHeader_MessageType_Pic,
        MessageHeader_MessageType_Emotion,
        MessageHeader_MessageType_Notice,
        MessageHeader_MessageType_UnknownMessageType,
    };
    static const char *extraTextFormatInfo = "\007\000\004\000\001\005\000\002\005\000\003\003\000\004\007\000\005\006\000\006\007\213\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageHeader_MessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageHeader_MessageType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageHeader_MessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageHeader_MessageType_Text:
    case MessageHeader_MessageType_Audio:
    case MessageHeader_MessageType_Video:
    case MessageHeader_MessageType_Pic:
    case MessageHeader_MessageType_Emotion:
    case MessageHeader_MessageType_Notice:
    case MessageHeader_MessageType_UnknownMessageType:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessageHeader_Property

@implementation MessageHeader_Property

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct MessageHeader_Property__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} MessageHeader_Property__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = MessageHeader_Property_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageHeader_Property__storage_, key),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = MessageHeader_Property_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageHeader_Property__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageHeader_Property class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageHeader_Property__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(MessageHeader)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextMessage

@implementation TextMessage

@dynamic hasHeader, header;
@dynamic hasText, text;

typedef struct TextMessage__storage_ {
  uint32_t _has_storage_[1];
  MessageHeader *header;
  NSString *text;
} TextMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHeader),
        .number = TextMessage_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextMessage__storage_, header),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = TextMessage_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextMessage__storage_, text),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextMessage class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AudioMessage

@implementation AudioMessage

@dynamic hasHeader, header;
@dynamic hasRecordSeconds, recordSeconds;
@dynamic hasAudioUri, audioUri;

typedef struct AudioMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t recordSeconds;
  MessageHeader *header;
  NSString *audioUri;
} AudioMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHeader),
        .number = AudioMessage_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AudioMessage__storage_, header),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recordSeconds",
        .dataTypeSpecific.className = NULL,
        .number = AudioMessage_FieldNumber_RecordSeconds,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AudioMessage__storage_, recordSeconds),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "audioUri",
        .dataTypeSpecific.className = NULL,
        .number = AudioMessage_FieldNumber_AudioUri,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AudioMessage__storage_, audioUri),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AudioMessage class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AudioMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\r\000\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VideoMessage

@implementation VideoMessage

@dynamic hasHeader, header;
@dynamic hasSource, source;
@dynamic hasVideoCover, videoCover;
@dynamic hasRecordSeconds, recordSeconds;
@dynamic hasVideoUri, videoUri;
@dynamic hasEncrypt, encrypt;

typedef struct VideoMessage__storage_ {
  uint32_t _has_storage_[1];
  MaterialSource source;
  int32_t recordSeconds;
  MessageHeader *header;
  NSString *videoCover;
  NSString *videoUri;
} VideoMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "header",
        .core.dataTypeSpecific.className = GPBStringifySymbol(MessageHeader),
        .core.number = VideoMessage_FieldNumber_Header,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(VideoMessage__storage_, header),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = MaterialSource_UnknownMaterialSource,
        .core.name = "source",
        .core.dataTypeSpecific.enumDescFunc = MaterialSource_EnumDescriptor,
        .core.number = VideoMessage_FieldNumber_Source,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(VideoMessage__storage_, source),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "videoCover",
        .core.dataTypeSpecific.className = NULL,
        .core.number = VideoMessage_FieldNumber_VideoCover,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(VideoMessage__storage_, videoCover),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "recordSeconds",
        .core.dataTypeSpecific.className = NULL,
        .core.number = VideoMessage_FieldNumber_RecordSeconds,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(VideoMessage__storage_, recordSeconds),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "videoUri",
        .core.dataTypeSpecific.className = NULL,
        .core.number = VideoMessage_FieldNumber_VideoUri,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(VideoMessage__storage_, videoUri),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "encrypt",
        .core.dataTypeSpecific.className = NULL,
        .core.number = VideoMessage_FieldNumber_Encrypt,
        .core.hasIndex = 5,
        .core.offset = 6,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VideoMessage class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(VideoMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\n\000\004\r\000\005\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PicMessage

@implementation PicMessage

@dynamic hasHeader, header;
@dynamic hasSource, source;
@dynamic hasCoverUri, coverUri;
@dynamic hasPicUri, picUri;
@dynamic hasEncrypt, encrypt;

typedef struct PicMessage__storage_ {
  uint32_t _has_storage_[1];
  MaterialSource source;
  MessageHeader *header;
  NSString *coverUri;
  NSString *picUri;
} PicMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "header",
        .core.dataTypeSpecific.className = GPBStringifySymbol(MessageHeader),
        .core.number = PicMessage_FieldNumber_Header,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(PicMessage__storage_, header),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = MaterialSource_UnknownMaterialSource,
        .core.name = "source",
        .core.dataTypeSpecific.enumDescFunc = MaterialSource_EnumDescriptor,
        .core.number = PicMessage_FieldNumber_Source,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(PicMessage__storage_, source),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "coverUri",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PicMessage_FieldNumber_CoverUri,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(PicMessage__storage_, coverUri),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "picUri",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PicMessage_FieldNumber_PicUri,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(PicMessage__storage_, picUri),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "encrypt",
        .core.dataTypeSpecific.className = NULL,
        .core.number = PicMessage_FieldNumber_Encrypt,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PicMessage class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(PicMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\010\000\004\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionMessage

@implementation EmotionMessage

@dynamic hasHeader, header;
@dynamic hasEmotionURL, emotionURL;
@dynamic hasEmotionId, emotionId;

typedef struct EmotionMessage__storage_ {
  uint32_t _has_storage_[1];
  MessageHeader *header;
  NSString *emotionURL;
  NSString *emotionId;
} EmotionMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHeader),
        .number = EmotionMessage_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionMessage__storage_, header),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emotionURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionMessage_FieldNumber_EmotionURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionMessage__storage_, emotionURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "emotionId",
        .dataTypeSpecific.className = NULL,
        .number = EmotionMessage_FieldNumber_EmotionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmotionMessage__storage_, emotionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionMessage class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\010!!\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NoticeMessage

@implementation NoticeMessage

@dynamic hasHeader, header;
@dynamic hasReferenceMsgId, referenceMsgId;
@dynamic hasReferenceTime, referenceTime;
@dynamic actionsArray, actionsArray_Count;
@dynamic hasActionType, actionType;
@dynamic hasCondition, condition;

typedef struct NoticeMessage__storage_ {
  uint32_t _has_storage_[1];
  NoticeMessage_ActionType actionType;
  MessageHeader *header;
  NSString *referenceMsgId;
  NSMutableArray *actionsArray;
  NoticeMessage_Condition *condition;
  int64_t referenceTime;
} NoticeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "header",
        .core.dataTypeSpecific.className = GPBStringifySymbol(MessageHeader),
        .core.number = NoticeMessage_FieldNumber_Header,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(NoticeMessage__storage_, header),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "referenceMsgId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = NoticeMessage_FieldNumber_ReferenceMsgId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(NoticeMessage__storage_, referenceMsgId),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt64 = 0LL,
        .core.name = "referenceTime",
        .core.dataTypeSpecific.className = NULL,
        .core.number = NoticeMessage_FieldNumber_ReferenceTime,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(NoticeMessage__storage_, referenceTime),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt64,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "actionsArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(NoticeMessage_Action),
        .core.number = NoticeMessage_FieldNumber_ActionsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(NoticeMessage__storage_, actionsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = NoticeMessage_ActionType_UnKnownActionType,
        .core.name = "actionType",
        .core.dataTypeSpecific.enumDescFunc = NoticeMessage_ActionType_EnumDescriptor,
        .core.number = NoticeMessage_FieldNumber_ActionType,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(NoticeMessage__storage_, actionType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "condition",
        .core.dataTypeSpecific.className = GPBStringifySymbol(NoticeMessage_Condition),
        .core.number = NoticeMessage_FieldNumber_Condition,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(NoticeMessage__storage_, condition),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NoticeMessage class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(NoticeMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\016\000\003\r\000\005\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum NoticeMessage_ActionType

GPBEnumDescriptor *NoticeMessage_ActionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ScreenShot\000SaveMessage\000Typing\000Normal\000Gro"
        "up\000BlackHole\000CleanSession\000UnKnownActionT"
        "ype\000";
    static const int32_t values[] = {
        NoticeMessage_ActionType_ScreenShot,
        NoticeMessage_ActionType_SaveMessage,
        NoticeMessage_ActionType_Typing,
        NoticeMessage_ActionType_Normal,
        NoticeMessage_ActionType_Group,
        NoticeMessage_ActionType_BlackHole,
        NoticeMessage_ActionType_CleanSession,
        NoticeMessage_ActionType_UnKnownActionType,
    };
    static const char *extraTextFormatInfo = "\010\000\n\000\001\013\000\002\006\000\003\006\000\004\005\000\005\t\000\006\014\000\007\007\212\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NoticeMessage_ActionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NoticeMessage_ActionType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NoticeMessage_ActionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case NoticeMessage_ActionType_ScreenShot:
    case NoticeMessage_ActionType_SaveMessage:
    case NoticeMessage_ActionType_Typing:
    case NoticeMessage_ActionType_Normal:
    case NoticeMessage_ActionType_Group:
    case NoticeMessage_ActionType_BlackHole:
    case NoticeMessage_ActionType_CleanSession:
    case NoticeMessage_ActionType_UnKnownActionType:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - NoticeMessage_Action

@implementation NoticeMessage_Action

@dynamic hasText, text;
@dynamic hasURL, URL;
@dynamic hasLocKey, locKey;

typedef struct NoticeMessage_Action__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
  NSString *URL;
  NSString *locKey;
} NoticeMessage_Action__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = NoticeMessage_Action_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NoticeMessage_Action__storage_, text),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = NoticeMessage_Action_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NoticeMessage_Action__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locKey",
        .dataTypeSpecific.className = NULL,
        .number = NoticeMessage_Action_FieldNumber_LocKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NoticeMessage_Action__storage_, locKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NoticeMessage_Action class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NoticeMessage_Action__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002!!!\000\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(NoticeMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NoticeMessage_Condition

@implementation NoticeMessage_Condition

@dynamic rangeArray, rangeArray_Count;
@dynamic hasUserLevel, userLevel;
@dynamic hasPriority, priority;

typedef struct NoticeMessage_Condition__storage_ {
  uint32_t _has_storage_[1];
  int32_t userLevel;
  NoticeMessage_Condition_Priority priority;
  NSMutableArray *rangeArray;
} NoticeMessage_Condition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "rangeArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(NoticeMessage_Condition_Range),
        .core.number = NoticeMessage_Condition_FieldNumber_RangeArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(NoticeMessage_Condition__storage_, rangeArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "userLevel",
        .core.dataTypeSpecific.className = NULL,
        .core.number = NoticeMessage_Condition_FieldNumber_UserLevel,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(NoticeMessage_Condition__storage_, userLevel),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueEnum = NoticeMessage_Condition_Priority_Deault,
        .core.name = "priority",
        .core.dataTypeSpecific.enumDescFunc = NoticeMessage_Condition_Priority_EnumDescriptor,
        .core.number = NoticeMessage_Condition_FieldNumber_Priority,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(NoticeMessage_Condition__storage_, priority),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NoticeMessage_Condition class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(NoticeMessage_Condition__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(NoticeMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum NoticeMessage_Condition_Priority

GPBEnumDescriptor *NoticeMessage_Condition_Priority_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Time\000Count\000Deault\000";
    static const int32_t values[] = {
        NoticeMessage_Condition_Priority_Time,
        NoticeMessage_Condition_Priority_Count,
        NoticeMessage_Condition_Priority_Deault,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NoticeMessage_Condition_Priority)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NoticeMessage_Condition_Priority_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NoticeMessage_Condition_Priority_IsValidValue(int32_t value__) {
  switch (value__) {
    case NoticeMessage_Condition_Priority_Time:
    case NoticeMessage_Condition_Priority_Count:
    case NoticeMessage_Condition_Priority_Deault:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - NoticeMessage_Condition_Range

@implementation NoticeMessage_Condition_Range

@dynamic hasStartMessageId, startMessageId;
@dynamic hasStartCreateTime, startCreateTime;
@dynamic hasEndMessageId, endMessageId;
@dynamic hasEndCreateTime, endCreateTime;
@dynamic hasMatchedCount, matchedCount;

typedef struct NoticeMessage_Condition_Range__storage_ {
  uint32_t _has_storage_[1];
  int32_t matchedCount;
  NSString *startMessageId;
  NSString *endMessageId;
  int64_t startCreateTime;
  int64_t endCreateTime;
} NoticeMessage_Condition_Range__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "startMessageId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = NoticeMessage_Condition_Range_FieldNumber_StartMessageId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(NoticeMessage_Condition_Range__storage_, startMessageId),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt64 = -1LL,
        .core.name = "startCreateTime",
        .core.dataTypeSpecific.className = NULL,
        .core.number = NoticeMessage_Condition_Range_FieldNumber_StartCreateTime,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(NoticeMessage_Condition_Range__storage_, startCreateTime),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt64,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "endMessageId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = NoticeMessage_Condition_Range_FieldNumber_EndMessageId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(NoticeMessage_Condition_Range__storage_, endMessageId),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt64 = -1LL,
        .core.name = "endCreateTime",
        .core.dataTypeSpecific.className = NULL,
        .core.number = NoticeMessage_Condition_Range_FieldNumber_EndCreateTime,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(NoticeMessage_Condition_Range__storage_, endCreateTime),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt64,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "matchedCount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = NoticeMessage_Condition_Range_FieldNumber_MatchedCount,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(NoticeMessage_Condition_Range__storage_, matchedCount),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NoticeMessage_Condition_Range class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(NoticeMessage_Condition_Range__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\016\000\002\017\000\003\014\000\004\r\000\005L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(NoticeMessage_Condition)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncPacket

@implementation SyncPacket

@dynamic hasFromUid, fromUid;
@dynamic hasSeqId, seqId;
@dynamic classifiedArray, classifiedArray_Count;

typedef struct SyncPacket__storage_ {
  uint32_t _has_storage_[1];
  NSString *fromUid;
  GPBEnumArray *classifiedArray;
  int64_t seqId;
} SyncPacket__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUid",
        .dataTypeSpecific.className = NULL,
        .number = SyncPacket_FieldNumber_FromUid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncPacket__storage_, fromUid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "seqId",
        .dataTypeSpecific.className = NULL,
        .number = SyncPacket_FieldNumber_SeqId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncPacket__storage_, seqId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "classifiedArray",
        .dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .number = SyncPacket_FieldNumber_ClassifiedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncPacket__storage_, classifiedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncPacket class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncPacket__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\007\000\002\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncDataPacket

@implementation SyncDataPacket

@dynamic hasRemoteUid, remoteUid;
@dynamic syncMarksArray, syncMarksArray_Count;
@dynamic hasSerilizableType, serilizableType;
@dynamic hasHasMore, hasMore;
@dynamic dataArray, dataArray_Count;
@dynamic hasSendTime, sendTime;

typedef struct SyncDataPacket__storage_ {
  uint32_t _has_storage_[1];
  SerializableType serilizableType;
  NSString *remoteUid;
  NSMutableArray *syncMarksArray;
  NSMutableArray *dataArray;
  int64_t sendTime;
} SyncDataPacket__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remoteUid",
        .dataTypeSpecific.className = NULL,
        .number = SyncDataPacket_FieldNumber_RemoteUid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncDataPacket__storage_, remoteUid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncMarksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SyncDataPacket_SyncMark),
        .number = SyncDataPacket_FieldNumber_SyncMarksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncDataPacket__storage_, syncMarksArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serilizableType",
        .dataTypeSpecific.enumDescFunc = SerializableType_EnumDescriptor,
        .number = SyncDataPacket_FieldNumber_SerilizableType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncDataPacket__storage_, serilizableType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "hasMore",
        .dataTypeSpecific.className = NULL,
        .number = SyncDataPacket_FieldNumber_HasMore,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SyncDataPacket_DataEntry),
        .number = SyncDataPacket_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncDataPacket__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.className = NULL,
        .number = SyncDataPacket_FieldNumber_SendTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SyncDataPacket__storage_, sendTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncDataPacket class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncDataPacket__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\t\000\002\000syncMarks\000\003\017\000\004\007\000\006\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncDataPacket_SyncMark

@implementation SyncDataPacket_SyncMark

@dynamic hasClassified, classified;
@dynamic hasLastVersion, lastVersion;
@dynamic hasTargetId, targetId;

typedef struct SyncDataPacket_SyncMark__storage_ {
  uint32_t _has_storage_[1];
  MessageClassified classified;
  NSString *targetId;
  int64_t lastVersion;
} SyncDataPacket_SyncMark__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = MessageClassified_UnknownMessageClassified,
        .core.name = "classified",
        .core.dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .core.number = SyncDataPacket_SyncMark_FieldNumber_Classified,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(SyncDataPacket_SyncMark__storage_, classified),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueInt64 = 0LL,
        .core.name = "lastVersion",
        .core.dataTypeSpecific.className = NULL,
        .core.number = SyncDataPacket_SyncMark_FieldNumber_LastVersion,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(SyncDataPacket_SyncMark__storage_, lastVersion),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt64,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "targetId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = SyncDataPacket_SyncMark_FieldNumber_TargetId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(SyncDataPacket_SyncMark__storage_, targetId),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncDataPacket_SyncMark class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(SyncDataPacket_SyncMark__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\013\000\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SyncDataPacket)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncDataPacket_DataEntry

@implementation SyncDataPacket_DataEntry

@dynamic hasClassified, classified;
@dynamic hasType, type;
@dynamic hasBody, body;

typedef struct SyncDataPacket_DataEntry__storage_ {
  uint32_t _has_storage_[1];
  MessageClassified classified;
  int32_t type;
  NSData *body;
} SyncDataPacket_DataEntry__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = MessageClassified_UnknownMessageClassified,
        .core.name = "classified",
        .core.dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .core.number = SyncDataPacket_DataEntry_FieldNumber_Classified,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(SyncDataPacket_DataEntry__storage_, classified),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "type",
        .core.dataTypeSpecific.className = NULL,
        .core.number = SyncDataPacket_DataEntry_FieldNumber_Type,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(SyncDataPacket_DataEntry__storage_, type),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "body",
        .core.dataTypeSpecific.className = NULL,
        .core.number = SyncDataPacket_DataEntry_FieldNumber_Body,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(SyncDataPacket_DataEntry__storage_, body),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncDataPacket_DataEntry class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(SyncDataPacket_DataEntry__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SyncDataPacket)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncDataFin

@implementation SyncDataFin

@dynamic syncMarksArray, syncMarksArray_Count;
@dynamic hasSendTime, sendTime;

typedef struct SyncDataFin__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *syncMarksArray;
  int64_t sendTime;
} SyncDataFin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "syncMarksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SyncDataPacket_SyncMark),
        .number = SyncDataFin_FieldNumber_SyncMarksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncDataFin__storage_, syncMarksArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.className = NULL,
        .number = SyncDataFin_FieldNumber_SendTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncDataFin__storage_, sendTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncDataFin class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncDataFin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000syncMarks\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncDataFinAck

@implementation SyncDataFinAck

@dynamic hasAckFinId, ackFinId;

typedef struct SyncDataFinAck__storage_ {
  uint32_t _has_storage_[1];
  int64_t ackFinId;
} SyncDataFinAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ackFinId",
        .dataTypeSpecific.className = NULL,
        .number = SyncDataFinAck_FieldNumber_AckFinId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncDataFinAck__storage_, ackFinId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncDataFinAck class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncDataFinAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewMessageNotify

@implementation NewMessageNotify

@dynamic classifiedArray, classifiedArray_Count;

typedef struct NewMessageNotify__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *classifiedArray;
} NewMessageNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "classifiedArray",
        .dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .number = NewMessageNotify_FieldNumber_ClassifiedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NewMessageNotify__storage_, classifiedArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewMessageNotify class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewMessageNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageArrivalAck

@implementation MessageArrivalAck

@dynamic hasHeader, header;
@dynamic hasCode, code;
@dynamic hasFeedback, feedback;
@dynamic hasClientTime, clientTime;

typedef struct MessageArrivalAck__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  MessageHeader *header;
  NSString *feedback;
  int64_t clientTime;
} MessageArrivalAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHeader),
        .number = MessageArrivalAck_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageArrivalAck__storage_, header),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = MessageArrivalAck_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageArrivalAck__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "feedback",
        .dataTypeSpecific.className = NULL,
        .number = MessageArrivalAck_FieldNumber_Feedback,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageArrivalAck__storage_, feedback),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientTime",
        .dataTypeSpecific.className = NULL,
        .number = MessageArrivalAck_FieldNumber_ClientTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageArrivalAck__storage_, clientTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageArrivalAck class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageArrivalAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageRead

@implementation MessageRead

@dynamic hasClassified, classified;
@dynamic hasFromUid, fromUid;
@dynamic hasRemoteUid, remoteUid;
@dynamic readMessageIdsArray, readMessageIdsArray_Count;
@dynamic hasUnreadCount, unreadCount;
@dynamic hasReadId, readId;
@dynamic hasGroupUnreadCount, groupUnreadCount;
@dynamic hasNewsUnreadCount, newsUnreadCount;

typedef struct MessageRead__storage_ {
  uint32_t _has_storage_[1];
  MessageClassified classified;
  int32_t unreadCount;
  int32_t groupUnreadCount;
  int32_t newsUnreadCount;
  NSString *fromUid;
  NSString *remoteUid;
  NSMutableArray *readMessageIdsArray;
  NSString *readId;
} MessageRead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = MessageClassified_UnknownMessageClassified,
        .core.name = "classified",
        .core.dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .core.number = MessageRead_FieldNumber_Classified,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(MessageRead__storage_, classified),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "fromUid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageRead_FieldNumber_FromUid,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(MessageRead__storage_, fromUid),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "remoteUid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageRead_FieldNumber_RemoteUid,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(MessageRead__storage_, remoteUid),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "readMessageIdsArray",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageRead_FieldNumber_ReadMessageIdsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(MessageRead__storage_, readMessageIdsArray),
        .core.flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "unreadCount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageRead_FieldNumber_UnreadCount,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(MessageRead__storage_, unreadCount),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "readId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageRead_FieldNumber_ReadId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(MessageRead__storage_, readId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "groupUnreadCount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageRead_FieldNumber_GroupUnreadCount,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(MessageRead__storage_, groupUnreadCount),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "newsUnreadCount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageRead_FieldNumber_NewsUnreadCount,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(MessageRead__storage_, newsUnreadCount),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageRead class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(MessageRead__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\002\007\000\003\t\000\004\000readMessageIds\000\005\013\000\006\006\000\007\020\000\010\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageReadAck

@implementation MessageReadAck

@dynamic hasClassified, classified;
@dynamic hasFromUid, fromUid;
@dynamic hasRemoteUid, remoteUid;
@dynamic readMessageIdsArray, readMessageIdsArray_Count;
@dynamic hasReadId, readId;

typedef struct MessageReadAck__storage_ {
  uint32_t _has_storage_[1];
  MessageClassified classified;
  NSString *fromUid;
  NSString *remoteUid;
  NSMutableArray *readMessageIdsArray;
  NSString *readId;
} MessageReadAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = MessageClassified_UnknownMessageClassified,
        .core.name = "classified",
        .core.dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .core.number = MessageReadAck_FieldNumber_Classified,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(MessageReadAck__storage_, classified),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "fromUid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageReadAck_FieldNumber_FromUid,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(MessageReadAck__storage_, fromUid),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "remoteUid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageReadAck_FieldNumber_RemoteUid,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(MessageReadAck__storage_, remoteUid),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "readMessageIdsArray",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageReadAck_FieldNumber_ReadMessageIdsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(MessageReadAck__storage_, readMessageIdsArray),
        .core.flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "readId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = MessageReadAck_FieldNumber_ReadId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(MessageReadAck__storage_, readId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageReadAck class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(MessageReadAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\007\000\003\t\000\004\000readMessageIds\000\005\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - News

@implementation News

@dynamic hasText, text;
@dynamic hasFromUid, fromUid;
@dynamic hasRemoteUid, remoteUid;
@dynamic hasNewsType, newsType;
@dynamic hasClassified, classified;
@dynamic hasPush, push;

typedef struct News__storage_ {
  uint32_t _has_storage_[1];
  News_NewsType newsType;
  MessageClassified classified;
  NSString *text;
  NSString *fromUid;
  NSString *remoteUid;
  Push *push;
} News__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "text",
        .core.dataTypeSpecific.className = NULL,
        .core.number = News_FieldNumber_Text,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(News__storage_, text),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "fromUid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = News_FieldNumber_FromUid,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(News__storage_, fromUid),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "remoteUid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = News_FieldNumber_RemoteUid,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(News__storage_, remoteUid),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = News_NewsType_UnknownNewsType,
        .core.name = "newsType",
        .core.dataTypeSpecific.enumDescFunc = News_NewsType_EnumDescriptor,
        .core.number = News_FieldNumber_NewsType,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(News__storage_, newsType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = MessageClassified_UnknownMessageClassified,
        .core.name = "classified",
        .core.dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .core.number = News_FieldNumber_Classified,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(News__storage_, classified),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "push",
        .core.dataTypeSpecific.className = GPBStringifySymbol(Push),
        .core.number = News_FieldNumber_Push,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(News__storage_, push),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[News class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(News__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\007\000\003\t\000\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum News_NewsType

GPBEnumDescriptor *News_NewsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Follow\000UnFollow\000Forward\000PostMention\000Comm"
        "entMention\000ReplyMention\000Comment\000Reply\000Po"
        "stLike\000CommentLike\000ReplyLike\000SuperLike\000F"
        "orwardComment\000UnknownNewsType\000";
    static const int32_t values[] = {
        News_NewsType_Follow,
        News_NewsType_UnFollow,
        News_NewsType_Forward,
        News_NewsType_PostMention,
        News_NewsType_CommentMention,
        News_NewsType_ReplyMention,
        News_NewsType_Comment,
        News_NewsType_Reply,
        News_NewsType_PostLike,
        News_NewsType_CommentLike,
        News_NewsType_ReplyLike,
        News_NewsType_SuperLike,
        News_NewsType_ForwardComment,
        News_NewsType_UnknownNewsType,
    };
    static const char *extraTextFormatInfo = "\016\000\006\000\001\010\000\002\007\000\003\013\000\004\016\000\005\014\000\006\007\000\007\005\000\010\010\000\t\013\000\n\t\000\013\t\000\014\016\000\r\007\210\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(News_NewsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:News_NewsType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL News_NewsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case News_NewsType_Follow:
    case News_NewsType_UnFollow:
    case News_NewsType_Forward:
    case News_NewsType_PostMention:
    case News_NewsType_CommentMention:
    case News_NewsType_ReplyMention:
    case News_NewsType_Comment:
    case News_NewsType_Reply:
    case News_NewsType_PostLike:
    case News_NewsType_CommentLike:
    case News_NewsType_ReplyLike:
    case News_NewsType_SuperLike:
    case News_NewsType_ForwardComment:
    case News_NewsType_UnknownNewsType:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Push

@implementation Push

@dynamic hasPushContent, pushContent;
@dynamic hasPushTitle, pushTitle;
@dynamic hasPushIcon, pushIcon;
@dynamic hasPushUserName, pushUserName;
@dynamic hasPushAvatarURL, pushAvatarURL;
@dynamic hasPushForwardURL, pushForwardURL;
@dynamic hasPushType, pushType;

typedef struct Push__storage_ {
  uint32_t _has_storage_[1];
  int32_t pushType;
  NSString *pushContent;
  NSString *pushTitle;
  NSString *pushIcon;
  NSString *pushUserName;
  NSString *pushAvatarURL;
  NSString *pushForwardURL;
} Push__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pushContent",
        .dataTypeSpecific.className = NULL,
        .number = Push_FieldNumber_PushContent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Push__storage_, pushContent),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushTitle",
        .dataTypeSpecific.className = NULL,
        .number = Push_FieldNumber_PushTitle,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Push__storage_, pushTitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushIcon",
        .dataTypeSpecific.className = NULL,
        .number = Push_FieldNumber_PushIcon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Push__storage_, pushIcon),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushUserName",
        .dataTypeSpecific.className = NULL,
        .number = Push_FieldNumber_PushUserName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Push__storage_, pushUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushAvatarURL",
        .dataTypeSpecific.className = NULL,
        .number = Push_FieldNumber_PushAvatarURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Push__storage_, pushAvatarURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushForwardURL",
        .dataTypeSpecific.className = NULL,
        .number = Push_FieldNumber_PushForwardURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Push__storage_, pushForwardURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushType",
        .dataTypeSpecific.className = NULL,
        .number = Push_FieldNumber_PushType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Push__storage_, pushType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Push class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Push__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\013\000\002\t\000\003\010\000\004\014\000\005\013!!\000\006\014!!\000\007\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MeetingInfo

@implementation MeetingInfo

@dynamic hasHostId, hostId;
@dynamic hasMeetingId, meetingId;
@dynamic hasOpenId, openId;

typedef struct MeetingInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *hostId;
  NSString *meetingId;
  NSString *openId;
} MeetingInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hostId",
        .dataTypeSpecific.className = NULL,
        .number = MeetingInfo_FieldNumber_HostId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MeetingInfo__storage_, hostId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meetingId",
        .dataTypeSpecific.className = NULL,
        .number = MeetingInfo_FieldNumber_MeetingId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MeetingInfo__storage_, meetingId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "openId",
        .dataTypeSpecific.className = NULL,
        .number = MeetingInfo_FieldNumber_OpenId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MeetingInfo__storage_, openId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MeetingInfo class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MeetingInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006\000\002\t\000\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OnlineReq

@implementation OnlineReq

@dynamic hasFromUid, fromUid;
@dynamic hasRemoteUid, remoteUid;
@dynamic hasViewTarget, viewTarget;
@dynamic hasClassified, classified;
@dynamic hasStatus, status;
@dynamic hasRequestId, requestId;

typedef struct OnlineReq__storage_ {
  uint32_t _has_storage_[1];
  MessageClassified classified;
  OnlineReq_OnlineStatus status;
  NSString *fromUid;
  NSString *remoteUid;
  NSString *viewTarget;
  NSString *requestId;
} OnlineReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUid",
        .dataTypeSpecific.className = NULL,
        .number = OnlineReq_FieldNumber_FromUid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OnlineReq__storage_, fromUid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remoteUid",
        .dataTypeSpecific.className = NULL,
        .number = OnlineReq_FieldNumber_RemoteUid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OnlineReq__storage_, remoteUid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "viewTarget",
        .dataTypeSpecific.className = NULL,
        .number = OnlineReq_FieldNumber_ViewTarget,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OnlineReq__storage_, viewTarget),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "classified",
        .dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .number = OnlineReq_FieldNumber_Classified,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OnlineReq__storage_, classified),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = OnlineReq_OnlineStatus_EnumDescriptor,
        .number = OnlineReq_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OnlineReq__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = OnlineReq_FieldNumber_RequestId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OnlineReq__storage_, requestId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OnlineReq class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OnlineReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\007\000\002\t\000\003\n\000\006\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum OnlineReq_OnlineStatus

GPBEnumDescriptor *OnlineReq_OnlineStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Online\000Offline\000UnknownNewsType\000";
    static const int32_t values[] = {
        OnlineReq_OnlineStatus_Online,
        OnlineReq_OnlineStatus_Offline,
        OnlineReq_OnlineStatus_UnknownNewsType,
    };
    static const char *extraTextFormatInfo = "\001\002\007\210\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OnlineReq_OnlineStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OnlineReq_OnlineStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OnlineReq_OnlineStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case OnlineReq_OnlineStatus_Online:
    case OnlineReq_OnlineStatus_Offline:
    case OnlineReq_OnlineStatus_UnknownNewsType:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - OnlineReqAck

@implementation OnlineReqAck

@dynamic hasCode, code;
@dynamic hasFromUid, fromUid;
@dynamic hasRemoteUid, remoteUid;
@dynamic hasFeedback, feedback;
@dynamic hasClassified, classified;
@dynamic memberIdsArray, memberIdsArray_Count;
@dynamic hasRequestId, requestId;

typedef struct OnlineReqAck__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  MessageClassified classified;
  NSString *fromUid;
  NSString *remoteUid;
  NSString *feedback;
  NSMutableArray *memberIdsArray;
  NSString *requestId;
} OnlineReqAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = OnlineReqAck_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OnlineReqAck__storage_, code),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fromUid",
        .dataTypeSpecific.className = NULL,
        .number = OnlineReqAck_FieldNumber_FromUid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OnlineReqAck__storage_, fromUid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remoteUid",
        .dataTypeSpecific.className = NULL,
        .number = OnlineReqAck_FieldNumber_RemoteUid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OnlineReqAck__storage_, remoteUid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "feedback",
        .dataTypeSpecific.className = NULL,
        .number = OnlineReqAck_FieldNumber_Feedback,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OnlineReqAck__storage_, feedback),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "classified",
        .dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .number = OnlineReqAck_FieldNumber_Classified,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OnlineReqAck__storage_, classified),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "memberIdsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Member),
        .number = OnlineReqAck_FieldNumber_MemberIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OnlineReqAck__storage_, memberIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = OnlineReqAck_FieldNumber_RequestId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OnlineReqAck__storage_, requestId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OnlineReqAck class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OnlineReqAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\007\000\003\t\000\006\000memberIds\000\007\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Member

@implementation Member

@dynamic hasMemberId, memberId;

typedef struct Member__storage_ {
  uint32_t _has_storage_[1];
  NSString *memberId;
} Member__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberId",
        .dataTypeSpecific.className = NULL,
        .number = Member_FieldNumber_MemberId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Member__storage_, memberId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Member class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Member__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastReq

@implementation BroadcastReq

@dynamic hasFromUid, fromUid;
@dynamic hasRemoteUid, remoteUid;
@dynamic hasViewTarget, viewTarget;
@dynamic hasClassified, classified;
@dynamic hasStatus, status;
@dynamic hasRequestId, requestId;
@dynamic hasInfo, info;
@dynamic hasBroadcastId, broadcastId;

typedef struct BroadcastReq__storage_ {
  uint32_t _has_storage_[1];
  MessageClassified classified;
  BroadcastReq_BroadcastStatus status;
  NSString *fromUid;
  NSString *remoteUid;
  NSString *viewTarget;
  NSString *requestId;
  MeetingInfo *info;
  NSString *broadcastId;
} BroadcastReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUid",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastReq_FieldNumber_FromUid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BroadcastReq__storage_, fromUid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remoteUid",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastReq_FieldNumber_RemoteUid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BroadcastReq__storage_, remoteUid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "viewTarget",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastReq_FieldNumber_ViewTarget,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BroadcastReq__storage_, viewTarget),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "classified",
        .dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .number = BroadcastReq_FieldNumber_Classified,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BroadcastReq__storage_, classified),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = BroadcastReq_BroadcastStatus_EnumDescriptor,
        .number = BroadcastReq_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BroadcastReq__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastReq_FieldNumber_RequestId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BroadcastReq__storage_, requestId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(MeetingInfo),
        .number = BroadcastReq_FieldNumber_Info,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BroadcastReq__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "broadcastId",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastReq_FieldNumber_BroadcastId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BroadcastReq__storage_, broadcastId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastReq class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\007\000\002\t\000\003\n\000\006\t\000\010\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum BroadcastReq_BroadcastStatus

GPBEnumDescriptor *BroadcastReq_BroadcastStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Open\000Close\000Enter\000UnknownNewsType\000";
    static const int32_t values[] = {
        BroadcastReq_BroadcastStatus_Open,
        BroadcastReq_BroadcastStatus_Close,
        BroadcastReq_BroadcastStatus_Enter,
        BroadcastReq_BroadcastStatus_UnknownNewsType,
    };
    static const char *extraTextFormatInfo = "\001\003\007\210\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BroadcastReq_BroadcastStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BroadcastReq_BroadcastStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BroadcastReq_BroadcastStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case BroadcastReq_BroadcastStatus_Open:
    case BroadcastReq_BroadcastStatus_Close:
    case BroadcastReq_BroadcastStatus_Enter:
    case BroadcastReq_BroadcastStatus_UnknownNewsType:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BroadcastReqAck

@implementation BroadcastReqAck

@dynamic hasCode, code;
@dynamic hasFromUid, fromUid;
@dynamic hasRemoteUid, remoteUid;
@dynamic hasFeedback, feedback;
@dynamic hasClassified, classified;
@dynamic hasMeetingInfo, meetingInfo;
@dynamic hasRequestId, requestId;

typedef struct BroadcastReqAck__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  MessageClassified classified;
  NSString *fromUid;
  NSString *remoteUid;
  NSString *feedback;
  MeetingInfo *meetingInfo;
  NSString *requestId;
} BroadcastReqAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastReqAck_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BroadcastReqAck__storage_, code),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fromUid",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastReqAck_FieldNumber_FromUid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BroadcastReqAck__storage_, fromUid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remoteUid",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastReqAck_FieldNumber_RemoteUid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BroadcastReqAck__storage_, remoteUid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "feedback",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastReqAck_FieldNumber_Feedback,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BroadcastReqAck__storage_, feedback),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "classified",
        .dataTypeSpecific.enumDescFunc = MessageClassified_EnumDescriptor,
        .number = BroadcastReqAck_FieldNumber_Classified,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BroadcastReqAck__storage_, classified),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "meetingInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(MeetingInfo),
        .number = BroadcastReqAck_FieldNumber_MeetingInfo,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BroadcastReqAck__storage_, meetingInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = BroadcastReqAck_FieldNumber_RequestId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BroadcastReqAck__storage_, requestId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastReqAck class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastReqAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\007\000\003\t\000\006\013\000\007\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageRecalled

@implementation MessageRecalled

@dynamic hasHeader, header;
@dynamic refHeaderArray, refHeaderArray_Count;

typedef struct MessageRecalled__storage_ {
  uint32_t _has_storage_[1];
  MessageHeader *header;
  NSMutableArray *refHeaderArray;
} MessageRecalled__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHeader),
        .number = MessageRecalled_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageRecalled__storage_, header),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "refHeaderArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHeader),
        .number = MessageRecalled_FieldNumber_RefHeaderArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MessageRecalled__storage_, refHeaderArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageRecalled class]
                                     rootClass:[BibiProtoApplicationRoot class]
                                          file:BibiProtoApplicationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageRecalled__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000refHeader\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
